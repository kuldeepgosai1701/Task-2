<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GPS Motion Tracker with Leaflet</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body, html {
     height: 100%;
     display: flex;
     flex-direction: column; }

    header {
      background: #004080;
      color: #fff;
      text-align: center;
      padding: 15px;
      font-size: 1.6rem;
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    .sensitivity-box {
      position: fixed;
      top: 70px;
      right: 20px;
      background: rgba(0, 64, 128, 0.9);
      color: #fff;
      padding: 12px 16px;
      border-radius: 12px;
      z-index: 1001;
    }

    .sensitivity-box input[type="range"] {
      width: 150px;
    }

    .info {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 12px;
      z-index: 1001;
      width: 250px;
    }

    button {
      margin-top: 5px;
      padding: 8px 14px;
      font-size: 0.9rem;
      font-weight: 600;
      border: none;
      background: linear-gradient(120deg, #007bff, #0056b3);
      color: white;
      border-radius: 6px;
      cursor: pointer;
    }
    button:hover {
      background: linear-gradient(120deg, #0056b3, #003f8c);
    }

    #map {
     flex: 1;
     width: 100%;
     position: relative; /* remove absolute positioning */
    }

    footer {
      background: linear-gradient(90deg, #004080, #0066cc);
       color: white;
  text-align: center;
  padding: 14px;
  font-size: 1rem;
    }
  </style>
</head>

<body>
<header>
</h1>Motion Tracker</h1>
<button onclick="openHistoryPage()" style="float: right; margin-right: 10px;">History</button>
</header>

<div class="sensitivity-box">
  <h3>Sensitivity</h3>
  <input type="range" id="sensitivityRange" min="0" max="10" step="1" value="5">
  <div>Value: <span id="sensVal">5</span></div>
</div>

<div class="info">
  <p>üìç Tracker Info</p>
  <p id="location">Location: Fetching...</p>
  <p id="direction">Direction: Calculating...</p>
  <button onclick="startTracking()">Start</button>
  <button onclick="stopTracking()">Stop</button>
  <button onclick="resetPage()">Reset</button>
  
</div>

<!-- Map container -->
<div id="map"></div>

<!-- History Modal -->
<div id="historyModal" 
     style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
            background:#fff; padding:20px; border-radius:12px; box-shadow:0px 4px 15px rgba(0,0,0,0.3);
            z-index:2000; width:300px; max-height:400px; overflow:auto;">
  <h3>üìå History</h3>
  <ul id="historyList" style="list-style:none; padding-left:0;"></ul>
  <button onclick="closeHistory()" 
          style="margin-top:10px; background:#d9534f; color:#fff; border:none; padding:6px 12px; border-radius:6px;">Close</button>
</div>

<footer>
<p>Created by Kuldeep Gosai</p>
</footer>
</body>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>

  window.onload = function() {
  localStorage.removeItem("gpsHistory");
  localStorage.removeItem("recordedData");
  localStorage.removeItem("sessions");
};

  let prevLat = null, prevLon = null;
  let gpsHistory = [];
  let sessionStartTime = null;
  let recordedData = [];
  let sensitivityFactor = 5;

   /*localStorage.removeItem("currentSession");

  gpsHistory = [];
  recordedData = [];
  pathCoords = [];
  pathLine.setLatLngs(pathCoords);
  dotMarker.setLatLng([0, 0]);
  map.setView([0, 0], 18);*/

  // Gyroscope values track karne ke liye
window.addEventListener("deviceorientation", function(event) {
    let alpha = event.alpha; // rotation around z-axis
    let beta = event.beta;   // rotation around x-axis
    let gamma = event.gamma; // rotation around y-axis

    recordedData.push({ alpha, beta, gamma, time: Date.now() });
     // Keep only the last 10 entries in memory
    if (recordedData.length > 10) {
     recordedData.shift();
     }

    // Save automatically in localStorage (hidden background saving)
    localStorage.setItem("recordedData", JSON.stringify(recordedData));

    
    // Sudden change detection (pothole condition)
    if (Math.abs(beta) > sensitivityFactor * 5 || Math.abs(gamma) > sensitivityFactor * 5) {
        vibratedRecently = true;
        if (navigator.vibrate) navigator.vibrate(300); // vibrate for 0.3s
    } else {
        vibratedRecently = false;
    }
}, true);
  /*window.addEventListener("deviceorientation", function(event) {
    let alpha = event.alpha;
    let beta = event.beta;
    let gamma = event.gamma;

    let vibration = (Math.abs(beta) > sensitivityFactor * 5 || Math.abs(gamma) > sensitivityFactor * 5);

    recordedData.push({ alpha, beta, gamma, time: Date.now(), vibration, direction: null });

     // üîπ Prevent unlimited growth (memory crash fix)
    if (recordedData.length > 1000) {
        recordedData.shift(); // purana data hatao
    }

    localStorage.setItem("recordedData", JSON.stringify(recordedData));

    if (vibration) {
        vibratedRecently = true;
        if (navigator.vibrate) navigator.vibrate(300);
    } else {
        vibratedRecently = false;
    }
}, true);*/
  
  let vibratedRecently = false;
  let trackingInterval = null;

  const locationText = document.getElementById("location");
  const directionText = document.getElementById("direction");
  const sensitivityRange = document.getElementById("sensitivityRange");
  const sensVal = document.getElementById("sensVal");

  sensitivityRange.addEventListener("input", () => {
    sensitivityFactor = parseFloat(sensitivityRange.value);
    sensVal.textContent = sensitivityRange.value;
  });

  // Leaflet map setup
  let map = L.map('map').setView([0, 0], 18);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  let dotMarker = L.circleMarker([0, 0], {
    radius: 10,
    fillColor: "#007bff",
    color: "#003366",
    weight: 2,
    opacity: 1,
    fillOpacity: 0.9
  }).addTo(map);

  let pathCoords = [];
  let pathLine = L.polyline(pathCoords, { color: 'blue' }).addTo(map);

  function analyzeVibrations() {
  const sliderValue = parseInt(sensitivityRange.value);

  // Select last N entries based on slider
  const entriesToAnalyze = recordedData.slice(-sliderValue);

  // Perform vibration check only on these entries
  entriesToAnalyze.forEach(entry => {
    if (entry.vibration === "Yes") {
      console.log("Vibration detected in last", sliderValue, "entries");
    }
  });
}

function calculateDirection(lat1, lon1, lat2, lon2) {
  // degrees ‚Üí radians
  const toRad = (deg) => (deg * Math.PI) / 180;
  lat1 = toRad(lat1);
  lon1 = toRad(lon1);
  lat2 = toRad(lat2);
  lon2 = toRad(lon2);

  // formula for bearing
  const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
  const x =
    Math.cos(lat1) * Math.sin(lat2) -
    Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);

  let brng = Math.atan2(y, x) * (180 / Math.PI);
  brng = (brng + 360) % 360; // normalize to 0‚Äì360
  return brng;
}

function getDirectionName(angle) {
  if (angle >= 337.5 || angle < 22.5) return "North";
  if (angle >= 22.5 && angle < 67.5) return "North-East";
  if (angle >= 67.5 && angle < 112.5) return "East";
  if (angle >= 112.5 && angle < 157.5) return "South-East";
  if (angle >= 157.5 && angle < 202.5) return "South";
  if (angle >= 202.5 && angle < 247.5) return "South-West";
  if (angle >= 247.5 && angle < 292.5) return "West";
  if (angle >= 292.5 && angle < 337.5) return "North-West";
  return "Unknown";
}

// --- Direction calculation and permission setup ---
function handleOrientation(event) {
  if (event.alpha !== null) {
    let heading = 360 - event.alpha; // Normalize to make 0¬∞ = North
    if (heading < 0) heading += 360;

    const direction = getDirectionName(heading);
    document.getElementById("direction").textContent =
      `Direction: ${direction} (${Math.round(heading)}¬∞)`;
  } else {
    document.getElementById("direction").textContent =
      "Direction: Unavailable";
  }
}

// iOS Safari Permission Handling
if (typeof DeviceOrientationEvent !== "undefined" &&
    typeof DeviceOrientationEvent.requestPermission === "function") {
  document.body.addEventListener("click", () => {
    DeviceOrientationEvent.requestPermission()
      .then(permissionState => {
        if (permissionState === "granted") {
          window.addEventListener("deviceorientation", handleOrientation);
        } else {
          alert("Direction sensor permission denied!");
        }
      })
      .catch(console.error);
  });
} else {
  // For Android and non-iOS browsers
  window.addEventListener("deviceorientation", handleOrientation);
}

function checkVibration(data) {
    return data.some(entry => entry.vibration === true);
}

function showLocation(position) {
    const lat = position.coords.latitude;
    const lon = position.coords.longitude;
    const timestamp = new Date().toISOString(); // store in ISO format

    // Get sessions array from localStorage
    let sessions = JSON.parse(localStorage.getItem("sessions")) || [];

    // If no session exists, create one
    if (sessions.length === 0) {
        sessions.push({
            start: timestamp,
            end: null,
            data: []
        });
    }

    // Reference current session
    let currentSession = sessions[sessions.length - 1];

    // ‚úÖ Always keep only the last 10 entries in current session
    currentSession.data.push({
    lat, 
    lon, 
    time: timestamp,
    vibration: vibratedRecently // <-- store vibration state here
});
if (currentSession.data.length > 10) {
    currentSession.data.shift();
}


    // Save back to localStorage
    localStorage.setItem("sessions", JSON.stringify(sessions));

    // UI update
    locationText.textContent = `Location: ${lat.toFixed(5)}, ${lon.toFixed(5)}`;
    pathCoords.push([lat, lon]);
    pathLine.setLatLngs(pathCoords);
    dotMarker.setLatLng([lat, lon]);
    map.setView([lat, lon]);

    // Calculate direction based on previous position
    if (prevLat !== null && prevLon !== null) {
       /* const dx = lon - prevLon;
        const dy = lat - prevLat;
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        directionText.textContent = `Direction: ${getDirectionFromAngle(angle)} (${Math.round(angle)}¬∞)`;*/
if (prevLat !== null && prevLon !== null) {
    const bearing = calculateDirection(prevLat, prevLon, lat, lon);
    directionText.textContent = `Direction: ${getDirectionName(bearing)} (${Math.round(bearing)}¬∞)`;
} else {
    directionText.textContent = "Direction: Calculating...";
}

    }

    // üî¥ Vibration detection logic
    const sliderVal = parseInt(sensitivityRange.value);
    const analyzeCount = Math.max(10 - sliderVal, 1);  // Always analyze 1 to 10 points
    const analyzeData = currentSession.data.slice(-analyzeCount);



    // Extract recent entries for analysis
    const analyzeDataGPS = currentSession.data.slice(-analyzeCount);

    // If vibration is detected in analyzed data ‚Üí mark red dot
   // If vibration detected in any of those entries ‚Üí mark red dot on map
if (checkVibration(analyzeData)) {
    L.circleMarker([lat, lon], {
        radius: 6,
        fillColor: "red",
        color: "darkred",
        weight: 2,
        opacity: 1,
        fillOpacity: 0.9
    }).addTo(map);
}

    prevLat = lat;
    prevLon = lon;
}

 function showError(error) {
  console.error("GPS Error:", error);
  switch(error.code) {
    case error.PERMISSION_DENIED:
      locationText.textContent = "Location: Permission denied";
      break;
    case error.POSITION_UNAVAILABLE:
      locationText.textContent = "Location: Position unavailable";
      break;
    case error.TIMEOUT:
      locationText.textContent = "Location: Timeout";
      break;
    default:
      locationText.textContent = "Location: Unknown error";
      break;
  }
}
function getDirectionFromAngle(angle) {
  // Normalize angle (-180 se 180 ko 0‚Äì360 me convert)
  angle = (angle + 360) % 360;

  if (angle >= 337.5 || angle < 22.5) return "East";
  if (angle >= 22.5 && angle < 67.5) return "North-East";
  if (angle >= 67.5 && angle < 112.5) return "North";
  if (angle >= 112.5 && angle < 157.5) return "North-West";
  if (angle >= 157.5 && angle < 202.5) return "West";
  if (angle >= 202.5 && angle < 247.5) return "South-West";
  if (angle >= 247.5 && angle < 292.5) return "South";
  if (angle >= 292.5 && angle < 337.5) return "South-East";
  
  return "Unknown";
}

function saveDataToFile() {

  const numberOfEntries = parseInt(sensitivityRange.value);

  // last N entries select 
  const recentData = recordedData.slice(-numberOfEntries);

  if (recentData.length === 0) {
    alert("No data to save.");
    return;
  }

let fileContent = "Alpha\tBeta\tGamma\tVibration\tDirection\n";
recentData.forEach(entry => {
  fileContent += `${entry.alpha.toFixed(2)}\t${entry.beta.toFixed(2)}\t${entry.gamma.toFixed(2)}\t${entry.vibration}\t${entry.direction}\n`;
});



  // download trigger 
  const blob = new Blob([fileContent], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `motion_data_last_${numberOfEntries}.txt`; 
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

  let watchId = null;

 function startTracking() {
  if ("geolocation" in navigator) {
    // ‚úÖ continuous GPS tracking
    trackingInterval = navigator.geolocation.watchPosition(
      showLocation,
      showError,
      {
        enableHighAccuracy: true,   // GPS chip use karega
        timeout: 10000,             // max wait 10 sec
        maximumAge: 0               // purana cache use na kare
      }
    );
  } else {
    alert("Geolocation not supported in this browser.");
  }
}
function startTracking() {
  if ("geolocation" in navigator) {
    let sessions = JSON.parse(localStorage.getItem("sessions")) || [];

    sessionStartTime = new Date();
    gpsHistory = []; // reset for new session
    localStorage.setItem("currentSession", JSON.stringify(gpsHistory));

    sessions.push({
      start: sessionStartTime.toISOString(),
      end: null,
      data: []
    });

    localStorage.setItem("sessions", JSON.stringify(sessions));

    watchId = navigator.geolocation.watchPosition(showLocation, showError, {
      enableHighAccuracy: true,
      maximumAge: 0,
      timeout: 5000
    });
  } else {
    alert("GPS not supported on this device/browser.");
  }
}

function stopTracking() {
  if (watchId !== null) {
    navigator.geolocation.clearWatch(watchId);
    watchId = null;

    let sessions = JSON.parse(localStorage.getItem("sessions")) || [];
    let current = sessions[sessions.length - 1];

    if (current && !current.end) {
      // Set the stop time correctly
      current.end = new Date().toISOString();
      // Merge any current path data into the session data
      current.data = [...current.data, ...gpsHistory];
      localStorage.setItem("sessions", JSON.stringify(sessions));
    }
  }
}




function resetPage() {
  pathCoords = [];
  pathLine.setLatLngs(pathCoords);

  if (prevLat && prevLon) {
    dotMarker.setLatLng([prevLat, prevLon]);
    map.panTo([prevLat, prevLon], {animate: true, duration: 0.5});
  }
}


/*function toggleHistory() {
    const modal = document.getElementById("historyModal");
    const list = document.getElementById("historyList");
    list.innerHTML = "";

    if (modal.style.display === "none") {
        if (gpsHistory.length === 0) {
            alert("No history available yet.");
            return;
        }

       
        const startTime = gpsHistory[0].time;
        const endTime = gpsHistory[gpsHistory.length - 1].time;

        const li = document.createElement("li");
        li.style.cursor = "pointer";
        li.textContent = `${startTime.toLocaleDateString()} ${startTime.toLocaleTimeString()} ‚Äì ${endTime.toLocaleTimeString()}`;
        li.onclick = () => showHistoryPath(startTime, endTime);
        list.appendChild(li);

        modal.style.display = "block";
    } else {
        modal.style.display = "none";
    }
}*/

function toggleHistory() {
    const modal = document.getElementById("historyModal");
    const list = document.getElementById("historyList");
    list.innerHTML = "";

    if (modal.style.display === "none") {
        const sessions = JSON.parse(localStorage.getItem("sessions")) || [];

        if (sessions.length === 0) {
            alert("No history available yet.");
            return;
        }

        
        sessions.forEach((session, index) => {
            const startTime = new Date(session.start);
            const endTime = session.end ? new Date(session.end) : null;

            const li = document.createElement("li");
            li.style.cursor = "pointer";
            li.textContent = endTime
                ? `Session ${index + 1}: ${startTime.toLocaleString()} - ${endTime.toLocaleString()}`
                : `Session ${index + 1}: ${startTime.toLocaleString()} - Ongoing`;

            li.onclick = () => {
                const path = session.data.map(p => [p.lat, p.lon]);
                if (path.length > 0) {
                    pathLine.setLatLngs(path);
                    dotMarker.setLatLng(path[path.length - 1]);
                    map.fitBounds(path);
                } else {
                    alert("No data in this session.");
                }
                closeHistory();
            };

            list.appendChild(li);
        });

        modal.style.display = "block";
    } else {
        modal.style.display = "none";
    }
}

function closeHistory() {
    document.getElementById("historyModal").style.display = "none";
}

function showHistoryPath(startTime, endTime) {
    // filter gpsHistory for selected time range
    const filteredPath = gpsHistory.filter(p => p.time >= startTime && p.time <= endTime)
                                   .map(p => [p.lat, p.lon]);

    if (filteredPath.length === 0) {
        alert("No movement in this interval.");
        return;
    }

    // clear existing path
    pathLine.setLatLngs(filteredPath);
    dotMarker.setLatLng(filteredPath[filteredPath.length - 1]);
    map.fitBounds(filteredPath);
    closeHistory();
}


  function openHistoryPage() {
    window.location.href = "history.html"; 
  }


window.onload = function() {
  const savedHistory = localStorage.getItem("gpsHistory");
  const savedRecorded = localStorage.getItem("recordedData");

  if (savedHistory) {
    gpsHistory = JSON.parse(savedHistory);
    // Map pe purana path show karo
    pathCoords = gpsHistory.map(p => [p.lat, p.lon]);
    pathLine.setLatLngs(pathCoords);
    if (pathCoords.length > 0) {
      dotMarker.setLatLng(pathCoords[pathCoords.length - 1]);
      map.fitBounds(pathCoords);
    }
  }

  if (savedRecorded) {
    recordedData = JSON.parse(savedRecorded);
  }

     localStorage.removeItem("currentSession");

  gpsHistory = [];
  recordedData = [];
  pathCoords = [];
  pathLine.setLatLngs(pathCoords);
  dotMarker.setLatLng([0, 0]);
  map.setView([0, 0], 18);
};
</script>
</body>
</html>


































































